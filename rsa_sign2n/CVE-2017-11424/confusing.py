import jwt
import json
import base64
from gmpy2 import mpz,gcd,c_div
import binascii
from Crypto.Hash import SHA256
from Crypto.Signature import PKCS1_v1_5 # god bless http://ratmirkarabut.com/articles/ctf-writeup-google-ctf-quals-2017-rsa-ctf-challenge/

def b64urldecode(b64):
    return base64.urlsafe_b64decode(b64+("="*(len(b64) % 4)))

def b64urlencode(m):
    return base64.urlsafe_b64encode(m).strip("=")

def bytes2mpz(b):
    return mpz(int(binascii.hexlify(b),16))

private_key = open("standard.pem","r").read()
public_key = open("standard.pub.pem","r").read()

print("Test JWTs:")
encoded = jwt.encode({"iss":"joe", "exp":1300819380, "http://example.com/is_root": True}, private_key, algorithm="RS256")
print(encoded)
encoded2 = jwt.encode({"iss":"joe", "exp":1300819381, "http://example.com/is_root": True}, private_key, algorithm="RS256")
print(encoded2)

print("="*80)

encoded_sig_bytes = b64urldecode(encoded.decode('utf8').split('.')[2])
encoded2_sig_bytes = b64urldecode(encoded2.decode('utf8').split('.')[2])

encoded_sig = bytes2mpz(encoded_sig_bytes)
encoded2_sig = bytes2mpz(encoded2_sig_bytes)

jks=json.loads(open("standard.jks.json","r").read())

n_bytes=b64urldecode(jks["n"])
p_bytes=b64urldecode(jks["p"])
q_bytes=b64urldecode(jks["q"])
d_bytes=b64urldecode(jks["d"])
e_bytes=b64urldecode(jks["e"])

n=bytes2mpz(n_bytes)
p=bytes2mpz(p_bytes)
q=bytes2mpz(q_bytes)
d=bytes2mpz(d_bytes)
e=bytes2mpz(e_bytes)

jks_input = ".".join(encoded.decode('utf8').split('.')[0:2])
sha256_0=SHA256.new(jks_input.encode('ascii'))
padded = PKCS1_v1_5.EMSA_PKCS1_V1_5_ENCODE(sha256_0, 256)

jks2_input = ".".join(encoded2.decode('utf8').split('.')[0:2])
sha256_2=SHA256.new(jks2_input.encode('ascii'))
padded2 = PKCS1_v1_5.EMSA_PKCS1_V1_5_ENCODE(sha256_2, 256)

m=bytes2mpz(padded) 
m2=bytes2mpz(padded2)

s0=pow(m,d,n)
s2=pow(m2,d,n)

print("Generated and calculated signatures should match:\n")
print("First signature:")
print(hex(s0))
print(hex(encoded_sig))
print("\nSecond signature:")
print(hex(s2))
print(hex(encoded2_sig))

print("-"*80)

gcd_res = gcd(pow(s0,e)-m,pow(s2,e)-m2)
#gcd_res = mpz(0x143f02c15c5c79368cb9d1a5acac4c66c5724fb7c53c3e048eff82c4b9921426dc717b2692f8b6dd4c7baee23ccf8e853f2ad61f7151e1135b896d3127982667ea7dba03370ef084a5fd9229fc90aeed2b297d48501a6581eab7ec5289e26072d78dd37bedd7ba57b46cf1dd9418cd1ee03671b7ff671906859c5fcda4ff5bc94b490e92f3ba9739f35bd898eb60b0a58581ebdf14b82ea0725f289d1dac982218d6c8ec13548f075d738d935aeaa6260a0c71706ccb8dedef505472ce0543ec83705a7d7e4724432923f6d0d0e58ae2dea15f06b1b35173a2f8680e51eff0fb13431b1f956cf5b08b2185d9eeb26726c780e069adec0df3c43c0a8ad95cbd342)
print("GCD: ",hex(gcd_res))

for my_gcd in range(1,100):
    my_n=c_div(gcd_res,mpz(my_gcd))
    if pow(s0,e,my_n) == m:
        print("Found n with multiplier" ,my_gcd, " :\n", hex(my_n))

